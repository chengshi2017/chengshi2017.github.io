<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Jenkins集成Sonar进行持续审查]]></title>
    <url>%2F2018%2F04%2F06%2FJenkins%E9%9B%86%E6%88%90Sonar%E8%BF%9B%E8%A1%8C%E6%8C%81%E7%BB%AD%E5%AE%A1%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;由于最近客户要求在devops持续集成平台上增加代码审计功能，经过一番对比，决定选用sonar来实现，通过网上的文档艰难的完成了安装，写篇博客记录下。 SonarQube 简介&emsp;&emsp;Sonar是一个用于代码质量管理的开源平台，用于管理Java源代码的质量。通过插件机制，Sonar 可以集成不同的测试工具，代码分析工具，以及持续集成工具，比如pmd-cpd、checkstyle、findbugs、Jenkins。通过不同的插件对这些结果进行再加工处理，通过量化的方式度量代码质量的变化，从而可以方便地对不同规模和种类的工程进行代码质量管理。同时 Sonar 还对大量的持续集成工具提供了接口支持，可以很方便地在持续集成中使用 Sonar。 此外，Sonar 的插件还可以对 Java 以外的其他编程语言提供支持，对国际化以及报告文档化也有良好的支持。Sonar可以从以下七个维度检测代码质量，而作为开发人员至少需要处理前5种代码质量问题&emsp;&emsp;1.不遵循代码标准&emsp;&emsp;sonar可以通过PMD,CheckStyle,Findbugs等等代码规则检测工具规范代码编写&emsp;&emsp;2.潜在的缺陷&emsp;&emsp;sonar可以通过PMD,CheckStyle,Findbugs等等代码规则检测工具检测出潜在的缺陷&emsp;&emsp;3.糟糕的复杂度分布&emsp;&emsp;文件、类、方法等，如果复杂度过高将难以改变，这会使得开发人员难以理解它们且如果没有自动化的单元测试，对于程序中的任何组件的改变都将可能导致需要全面的回归测试&emsp;&emsp;4.重复&emsp;&emsp;显然程序中包含大量复制粘贴的代码是质量低下的，sonar可以展示源码中重复严重的地方&emsp;&emsp;5.注释不足或者过多&emsp;&emsp;没有注释将使代码可读性变差，特别是当不可避免地出现人员变动时，程序的可读性将大幅下降而过多的注释又会使得开发人员将精力过多地花费在阅读注释上，亦违背初衷&emsp;&emsp;6.缺乏单元测试&emsp;&emsp;sonar可以很方便地统计并展示单元测试覆盖率&emsp;&emsp;7.糟糕的设计&emsp;&emsp;通过sonar可以找出循环，展示包与包、类与类之间的相互依赖关系，可以检测自定义的架构规则通过sonar可以管理第三方的jar包，可以利用LCOM4检测单个任务规则的应用情况， 检测耦合。 SonarQube与Sonar-Scanner的安装与配置下载sonarQube安装包&emsp;&emsp;SonarQube可以在官网(https://www.sonarqube.org/downloads/)下载，在Linux服务器上安装始终加载不到静态文件，所以最后决定直接在Windows服务器上安装sonar，将从官网下载的安装包解压到任意目录。 创建sonar数据库&emsp;&emsp;SonarQube自带了一个H2数据库，但是为了获得更好的性能还是选择MySQL数据库。首先在mysql中新建一个sonar数据库，用于存放分析的数据，并且新建一个数据库用户，实测直接用root账户会报错。1234&gt; CREATE USER 'sonar'@'%' IDENTIFIED BY 'password';&gt; GRANT all privileges ON sonarqube.* TO sonar'@''%' IDENTIFIED BY 'password';&gt; flush privileges;&gt; create database sonar; 注意：MySQL数据库一定要在5.6以上(sonar要求数据库支持事务，mysql5.6+才是InnerDB) 配置sonar应用mysql&emsp;&emsp;修改配置文件sonar.properties123456sonar.jdbc.username=sonarsonar.jdbc.password=sonarsonar.jdbc.url=jdbc:mysql://172.17.20.140:3307/sonar?useUnicode=true&amp;characterEncoding=utf8&amp;rewriteBatchedStatements=true&amp;useConfigs=maxPerformance&amp;useSSL=falsesonar.web.host=0.0.0.0sonar.web.context=/sonarsonar.web.port=9000 保存配置文件后，进入\bin\windows-x86-64目录下，双击startup.bat启动。如果启动过程没有报错，打开浏览器输入http://172.17.20.125:9000/sonar/，出现如下画面说明安装成功 配置Sonar-Scanner 进行项目代码审查&emsp;&emsp;下载sonar-scanner，解压到任意目录，同样的修改sonar.properties 配置文件12# --------指定系统中sonar访问路径sonar.host.url=http://localhost:9000/sonar 如果安装的不是同一台机器，将localhost修改为对应地址即可sonar-scanner在项目中使用需要在项目根目录下添加sonar-project.properties文件12345678#sonar-project.properties内容如下sonar.projectKey=project_keysonar.projectName=project_namesonar.projectVersion=1.0sonar.sources=./sonar.language=py //需要扫描哪种语言的代码，如python:py，java:javasonar.sourceEncoding=UTF-8sonar.host.url=http://your_host:your_port/[your_prefix] 进入项目根目录，启动cmd命令行，输入sonar-scanner，sonar-scanner会自动对项目进行检查，检查的结果发送到sonar服务器进行解析，然后反馈的用户。 将sonar集成到jenkins中&emsp;&emsp;将sonar配置到jenkins中，当使用jenkins自动化部署项目时，就能够自动的对代码进行检查1.手动下载jenkins插件SonarQube Scanner for Jenkins。也可以直接在jenkins中下载，在[Manage Jenkins]-[Global Tool Configuration]中配置JDK和Maven后，再在Jenkins上安装SonarQube插件。在[Manage Jenkins]-[Global Tool Configuration]中选择SonarQube Scanner for Jenkins插件，点击下载，下载完成后重启jenkins服务器。2.jenkins重启成功后，打开[Manage Jenkins]-[Configure System]和[Manage Jenkins]-[Global Tool Configuration]，可以看到新增了Sonar Qube的选项。在[Manage Jenkins]-[Configure System]中配置SonarQube Server。[Server authentication token]行对应的token请输入第一次启动sonar server时生成的token 在jenkins中配置sonar进行代码审查&emsp;&emsp;完成好以上步骤后，在进行项目编译打包时，点击[增加构建步骤]，会发现多了Execute SonarQube Scanner选项在Execute SonarQube Scanner中进行如下配置： Task to run 可以随便写，JDK一定要选择jenkins 中配置的jdk(版本不能太低，sonar要求jdk版本为1.8)，Path to project properties: 相当于sonar-scanner中的sonar-project.properties，如果在项目的根目录下有sonar-scanner配置文件配置即可。Additional arguments中可写可不写，个人习惯加上“-X”,表示以Debug的形式启动，能够显示更多的信息。Analysis properties示例如下图所示：123456sonar.projectKey=$proNamesonar.projectName=$proNamesonar.projectVersion=1.0sonar.sources=$&#123;proName&#125;/srcsonar.language=java sonar.sourceEncoding=UTF-8 在sonar-java插件4.10版本之后，还需要添加sonar.java.binaries=target/classes。但是因为打包时可能没有编译后的文件，所以我在sonarqube中替换了sonar-java-plugin文件，将版本改为4.10。 保存好Execute SonarQube Scanner配置，开始编译打包，查看日志 然后打开sonarqube server,即可查看分析结果 关于启动与关闭的问题&amp;&emsp;&emsp;sonar 如果安装在Linux服务器下，启动和关闭都不是问题，进入sonar安装目录的bin文件夹的Linux-x86-64目录下，直接使用命令启动1234# 启动sonar$ ./sonar.sh start# 关闭sonar$ ./sonar.sh stop 哎！公司服务器抽风，Linux安装一直出现静态资源没法加载，估计是环境的问题，但是没法改，只能在Windows服务器上安装。在Windows中启动比在Linux中更简单，直接进入安装目录下的[E:\sonarqube-6.7.3\bin\windows-x86-64]目录下，双击startSonar.bat启动。(选择Windows-x86-64还是32，根据系统中安装的jdk版本而定，必须跟jdk版本对应，Linux中同理)。Windows中启动简单，但是关闭却比较复杂，各种关联文件，一个个的都必须释放才能彻底关闭。]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring boot 配置热部署]]></title>
    <url>%2F2018%2F03%2F28%2Fspring%20boot%E9%85%8D%E7%BD%AE%E7%83%AD%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[什么是热部署？热部署，就是在应用正在运行的时候升级软件，却不需要重新启动应用。在开发过程中，热部署对我们的开发速度有很大的帮助。例如在我们修改Bug的时候对Jsp或者Java类进行了修改在不重新启动WEB服务器就能让修改生效,配置文件除外。 怎么样进行热部署如何在idea中设置Tomcat热部署1.首先打开idea，点击右上角的下拉框，选中Edit Configurations,如下图： 2.点击对话框左上角的加号，选择Tomcat Server，再选择Local子菜单 3.选择Deployment选项卡，对需要部署的项目文件做设置，点击加号选择Artifact，然后选择war exploded方式，这种方式是以文件夹方式部署的，而war是以war包的方式，exploded方式支持热部署，注意一定要选择exploded方式，否则无法实现热部署。 4.然后回到Server选项卡，设置On Update action和On frame detectivation选项，都设置为Update classes and resources，表示classes文件和资源文件都更新 5.如果只设置On Update action选项，则需要每次自己手动点击更新，设置了On frame detectivation，会监测窗口，idea窗口发生切换则自动更新文件在运行模式下，Java文件更新不会立即生效，可以选择debug模式运行。 spring boot热部署配置spring boot致力于快速应用开发领域，内置了很多的组件，让我们摆脱了spring MVC下冗余的配置，使我们的开发变得更加的便捷快速。spring boot在自动嵌入了Tomcat，无需部署war文件，便可使项目快速运行起来，因此spring boot的热部署也与Tomcat的热部署不一样。spring boot的热部署是使用devtools模块。devtools模块，是为开发者服务的一个模块。主要的功能就是代码修改后一般在5秒之内就会自动重新加载至服务器，相当于restart成功。 原理分析 在发现代码有更改之后，自动重新启动应用，但是其速度比手动停止后再启动还要快些，更快这里指的不是节省出来的手工操作的时间。 一个Base ClassLoader加载器，用于加载不会改变的第三方依赖的jar； 另一个Restart ClassLoader加载器，用于加载自己编写的类； 执行流程：当应用重启后，原先的Restart ClassLoader被丢掉、重新new一个Restart ClassLoader来加载这些修改过的东西，而Base ClassLoader却没有变化。这就是devtools重启速度快的原因。 如何实现热部署 1.修改项目的pom.xml文件在依赖中加入:123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;version&gt;1.5.7.RELEASE&lt;/version&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 在构建中加入:12345678&lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;addResources&gt;true&lt;/addResources&gt; &lt;/configuration&gt;&lt;/plugin&gt; 2.修改设置在idea中，还需要到设置里将project automatically勾选上；File-&gt;Setting，然后搜索“compiler” 将右侧project automatically勾上。 3.修改IDE配置使用ctrl+shift+a 快捷键搜索Registry，选择选择搜索出来的第一个，进入后找到“compiler.automake.allow.when.app.running”，勾上开启此功能即可。 4.应用热部署重新启动项目即可实现热部署，改动任意代码会立即生效，不用再每次重新启动项目]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring boot的配置文件application.properties详解]]></title>
    <url>%2F2018%2F03%2F28%2Fspring%20boot%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6application.properties%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;spring boot 设计之初的目的就是用来简化spring 应用的初始化搭建以及开发方式，使我们不用遵循固定的样本式配置，简化了开发过程。 但是我们在开发的过程中，却有些用法不得不配置，spring boot也给出了解决的办法，那就是配置全部都写在.properties或者.yml文件中。此博客正是记录.properties文件中的一些常用配置。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370# =================================================================== # COMMON SPRING BOOT PROPERTIES # # This sample file is provided as a guideline. Do NOT copy it in its # entirety to your own application. ^^^ # =================================================================== # ---------------------------------------- # CORE PROPERTIES # ---------------------------------------- # SPRING CONFIG (ConfigFileApplicationListener) spring.config.name= # config file name (default to &apos;application&apos;) spring.config.location= # location of config file # PROFILES spring.profiles= # comma list of active profiles # APPLICATION SETTINGS (SpringApplication) spring.main.sources= spring.main.web-environment= # detect by default spring.main.show-banner=true spring.main....= # see class for all properties # LOGGING logging.path=/var/logs logging.file=myapp.log logging.config= # IDENTITY (ContextIdApplicationContextInitializer) spring.application.name= spring.application.index= # EMBEDDED SERVER CONFIGURATION (ServerProperties) server.port=8080 server.address= # bind to a specific NIC server.session-timeout= # session timeout in seconds server.context-path= # the context path, defaults to &apos;/&apos; server.servlet-path= # the servlet path, defaults to &apos;/&apos; server.tomcat.access-log-pattern= # log pattern of the access log server.tomcat.access-log-enabled=false # is access logging enabled server.tomcat.protocol-header=x-forwarded-proto # ssl forward headers server.tomcat.remote-ip-header=x-forwarded-for server.tomcat.basedir=/tmp # base dir (usually not needed, defaults to tmp) server.tomcat.background-processor-delay=30; # in seconds server.tomcat.max-threads = 0 # number of threads in protocol handler server.tomcat.uri-encoding = UTF-8 # character encoding to use for URL decoding # SPRING MVC (HttpMapperProperties) http.mappers.json-pretty-print=false # pretty print JSON http.mappers.json-sort-keys=false # sort keys spring.mvc.locale= # set fixed locale, e.g. en_UK spring.mvc.date-format= # set fixed date format, e.g. dd/MM/yyyy spring.mvc.message-codes-resolver-format= # PREFIX_ERROR_CODE / POSTFIX_ERROR_CODE spring.view.prefix= # MVC view prefix spring.view.suffix= # ... and suffix spring.resources.cache-period= # cache timeouts in headers sent to browser spring.resources.add-mappings=true # if default mappings should be added # THYMELEAF (ThymeleafAutoConfiguration) spring.thymeleaf.prefix=classpath:/templates/ spring.thymeleaf.suffix=.html spring.thymeleaf.mode=HTML5 spring.thymeleaf.encoding=UTF-8 spring.thymeleaf.content-type=text/html # ;charset=&lt;encoding&gt; is added spring.thymeleaf.cache=true # set to false for hot refresh # FREEMARKER (FreeMarkerAutoConfiguration) spring.freemarker.allowRequestOverride=false spring.freemarker.allowSessionOverride=false spring.freemarker.cache=true spring.freemarker.checkTemplateLocation=true spring.freemarker.contentType=text/html spring.freemarker.exposeRequestAttributes=false spring.freemarker.exposeSessionAttributes=false spring.freemarker.exposeSpringMacroHelpers=false spring.freemarker.prefix= spring.freemarker.requestContextAttribute= spring.freemarker.settings.*= spring.freemarker.suffix=.ftl spring.freemarker.templateEncoding=UTF-8 spring.freemarker.templateLoaderPath=classpath:/templates/ spring.freemarker.viewNames= # whitelist of view names that can be resolved # GROOVY TEMPLATES (GroovyTemplateAutoConfiguration) spring.groovy.template.allowRequestOverride=false spring.groovy.template.allowSessionOverride=false spring.groovy.template.cache=true spring.groovy.template.configuration.*= # See Groovy&apos;s TemplateConfiguration spring.groovy.template.contentType=text/html spring.groovy.template.prefix=classpath:/templates/ spring.groovy.template.suffix=.tpl spring.groovy.template.templateEncoding=UTF-8 spring.groovy.template.viewNames= # whitelist of view names that can be resolved # VELOCITY TEMPLATES (VelocityAutoConfiguration) spring.velocity.allowRequestOverride=false spring.velocity.allowSessionOverride=false spring.velocity.cache=true spring.velocity.checkTemplateLocation=true spring.velocity.contentType=text/html spring.velocity.dateToolAttribute= spring.velocity.exposeRequestAttributes=false spring.velocity.exposeSessionAttributes=false spring.velocity.exposeSpringMacroHelpers=false spring.velocity.numberToolAttribute= spring.velocity.prefix= spring.velocity.properties.*= spring.velocity.requestContextAttribute= spring.velocity.resourceLoaderPath=classpath:/templates/ spring.velocity.suffix=.vm spring.velocity.templateEncoding=UTF-8 spring.velocity.viewNames= # whitelist of view names that can be resolved # INTERNATIONALIZATION (MessageSourceAutoConfiguration) spring.messages.basename=messages spring.messages.cacheSeconds=-1 spring.messages.encoding=UTF-8 # SECURITY (SecurityProperties) security.user.name=user # login username security.user.password= # login password security.user.role=USER # role assigned to the user security.require-ssl=false # advanced settings ... security.enable-csrf=false security.basic.enabled=true security.basic.realm=Spring security.basic.path= # /** security.headers.xss=false security.headers.cache=false security.headers.frame=false security.headers.contentType=false security.headers.hsts=all # none / domain / all security.sessions=stateless # always / never / if_required / stateless security.ignored=false # DATASOURCE (DataSourceAutoConfiguration &amp; DataSourceProperties) spring.datasource.name= # name of the data source spring.datasource.initialize=true # populate using data.sql spring.datasource.schema= # a schema (DDL) script resource reference spring.datasource.data= # a data (DML) script resource reference spring.datasource.platform= # the platform to use in the schema resource (schema-$&#123;platform&#125;.sql) spring.datasource.continueOnError=false # continue even if can&apos;t be initialized spring.datasource.separator=; # statement separator in SQL initialization scripts spring.datasource.driverClassName= # JDBC Settings... spring.datasource.url= spring.datasource.username= spring.datasource.password= spring.datasource.max-active=100 # Advanced configuration... spring.datasource.max-idle=8 spring.datasource.min-idle=8 spring.datasource.initial-size=10 spring.datasource.validation-query= spring.datasource.test-on-borrow=false spring.datasource.test-on-return=false spring.datasource.test-while-idle= spring.datasource.time-between-eviction-runs-millis= spring.datasource.min-evictable-idle-time-millis= spring.datasource.max-wait-millis= # MONGODB (MongoProperties) spring.data.mongodb.host= # the db host spring.data.mongodb.port=27017 # the connection port (defaults to 27107) spring.data.mongodb.uri=mongodb://localhost/test # connection URL spring.data.mongo.repositories.enabled=true # if spring data repository support is enabled # JPA (JpaBaseConfiguration, HibernateJpaAutoConfiguration) spring.jpa.properties.*= # properties to set on the JPA connection spring.jpa.openInView=true spring.jpa.show-sql=true spring.jpa.database-platform= spring.jpa.database= spring.jpa.generate-ddl=false # ignored by Hibernate, might be useful for other vendors spring.jpa.hibernate.naming-strategy= # naming classname spring.jpa.hibernate.ddl-auto= # defaults to create-drop for embedded dbs spring.data.jpa.repositories.enabled=true # if spring data repository support is enabled # SOLR (SolrProperties&#125;) spring.data.solr.host=http://127.0.0.1:8983/solr spring.data.solr.zkHost= spring.data.solr.repositories.enabled=true # if spring data repository support is enabled # ELASTICSEARCH (ElasticsearchProperties&#125;) spring.data.elasticsearch.cluster-name= # The cluster name (defaults to elasticsearch) spring.data.elasticsearch.cluster-nodes= # The address(es) of the server node (comma-separated; if not specified starts a client node) spring.data.elasticsearch.local=true # if local mode should be used with client nodes spring.data.elasticsearch.repositories.enabled=true # if spring data repository support is enabled # FLYWAY (FlywayProperties) flyway.locations=classpath:db/migrations # locations of migrations scripts flyway.schemas= # schemas to update flyway.initVersion= 1 # version to start migration flyway.prefix=V flyway.suffix=.sql flyway.enabled=true flyway.url= # JDBC url if you want Flyway to create its own DataSource flyway.user= # JDBC username if you want Flyway to create its own DataSource flyway.password= # JDBC password if you want Flyway to create its own DataSource # LIQUIBASE (LiquibaseProperties) liquibase.change-log=classpath:/db/changelog/db.changelog-master.yaml liquibase.contexts= # runtime contexts to use liquibase.default-schema= # default database schema to use liquibase.drop-first=false liquibase.enabled=true # JMX spring.jmx.enabled=true # Expose MBeans from Spring # RABBIT (RabbitProperties) spring.rabbitmq.host= # connection host spring.rabbitmq.port= # connection port spring.rabbitmq.addresses= # connection addresses (e.g. myhost:9999,otherhost:1111) spring.rabbitmq.username= # login user spring.rabbitmq.password= # login password spring.rabbitmq.virtualhost= spring.rabbitmq.dynamic= # REDIS (RedisProperties) spring.redis.host=localhost # server host spring.redis.password= # server password spring.redis.port=6379 # connection port spring.redis.pool.max-idle=8 # pool settings ... spring.redis.pool.min-idle=0 spring.redis.pool.max-active=8 spring.redis.pool.max-wait=-1 # ACTIVEMQ (ActiveMQProperties) spring.activemq.broker-url=tcp://localhost:61616 # connection URL spring.activemq.user= spring.activemq.password= spring.activemq.in-memory=true # broker kind to create if no broker-url is specified spring.activemq.pooled=false # HornetQ (HornetQProperties) spring.hornetq.mode= # connection mode (native, embedded) spring.hornetq.host=localhost # hornetQ host (native mode) spring.hornetq.port=5445 # hornetQ port (native mode) spring.hornetq.embedded.enabled=true # if the embedded server is enabled (needs hornetq-jms-server.jar) spring.hornetq.embedded.serverId= # auto-generated id of the embedded server (integer) spring.hornetq.embedded.persistent=false # message persistence spring.hornetq.embedded.data-directory= # location of data content (when persistence is enabled) spring.hornetq.embedded.queues= # comma separate queues to create on startup spring.hornetq.embedded.topics= # comma separate topics to create on startup spring.hornetq.embedded.cluster-password= # customer password (randomly generated by default) # JMS (JmsProperties) spring.jms.pub-sub-domain= # false for queue (default), true for topic # SPRING BATCH (BatchDatabaseInitializer) spring.batch.job.names=job1,job2 spring.batch.job.enabled=true spring.batch.initializer.enabled=true spring.batch.schema= # batch schema to load # AOP spring.aop.auto= spring.aop.proxy-target-class= # FILE ENCODING (FileEncodingApplicationListener) spring.mandatory-file-encoding=false # SPRING SOCIAL (SocialWebAutoConfiguration) spring.social.auto-connection-views=true # Set to true for default connection views or false if you provide your own # SPRING SOCIAL FACEBOOK (FacebookAutoConfiguration) spring.social.facebook.app-id= # your application&apos;s Facebook App ID spring.social.facebook.app-secret= # your application&apos;s Facebook App Secret # SPRING SOCIAL LINKEDIN (LinkedInAutoConfiguration) spring.social.linkedin.app-id= # your application&apos;s LinkedIn App ID spring.social.linkedin.app-secret= # your application&apos;s LinkedIn App Secret # SPRING SOCIAL TWITTER (TwitterAutoConfiguration) spring.social.twitter.app-id= # your application&apos;s Twitter App ID spring.social.twitter.app-secret= # your application&apos;s Twitter App Secret # SPRING MOBILE SITE PREFERENCE (SitePreferenceAutoConfiguration) spring.mobile.sitepreference.enabled=true # enabled by default # SPRING MOBILE DEVICE VIEWS (DeviceDelegatingViewResolverAutoConfiguration) spring.mobile.devicedelegatingviewresolver.enabled=true # disabled by default spring.mobile.devicedelegatingviewresolver.normalPrefix= spring.mobile.devicedelegatingviewresolver.normalSuffix= spring.mobile.devicedelegatingviewresolver.mobilePrefix=mobile/ spring.mobile.devicedelegatingviewresolver.mobileSuffix= spring.mobile.devicedelegatingviewresolver.tabletPrefix=tablet/ spring.mobile.devicedelegatingviewresolver.tabletSuffix= # ---------------------------------------- # ACTUATOR PROPERTIES # ---------------------------------------- # MANAGEMENT HTTP SERVER (ManagementServerProperties) management.port= # defaults to &apos;server.port&apos; management.address= # bind to a specific NIC management.contextPath= # default to &apos;/&apos; # ENDPOINTS (AbstractEndpoint subclasses) endpoints.autoconfig.id=autoconfig endpoints.autoconfig.sensitive=true endpoints.autoconfig.enabled=true endpoints.beans.id=beans endpoints.beans.sensitive=true endpoints.beans.enabled=true endpoints.configprops.id=configprops endpoints.configprops.sensitive=true endpoints.configprops.enabled=true endpoints.configprops.keys-to-sanitize=password,secret endpoints.dump.id=dump endpoints.dump.sensitive=true endpoints.dump.enabled=true endpoints.env.id=env endpoints.env.sensitive=true endpoints.env.enabled=true endpoints.health.id=health endpoints.health.sensitive=false endpoints.health.enabled=true endpoints.info.id=info endpoints.info.sensitive=false endpoints.info.enabled=true endpoints.metrics.id=metrics endpoints.metrics.sensitive=true endpoints.metrics.enabled=true endpoints.shutdown.id=shutdown endpoints.shutdown.sensitive=true endpoints.shutdown.enabled=false endpoints.trace.id=trace endpoints.trace.sensitive=true endpoints.trace.enabled=true # MVC ONLY ENDPOINTS endpoints.jolokia.path=jolokia endpoints.jolokia.sensitive=true endpoints.jolokia.enabled=true # when using Jolokia endpoints.error.path=/error # JMX ENDPOINT (EndpointMBeanExportProperties) endpoints.jmx.enabled=true endpoints.jmx.domain= # the JMX domain, defaults to &apos;org.springboot&apos; endpoints.jmx.unique-names=false endpoints.jmx.enabled=true endpoints.jmx.staticNames= # JOLOKIA (JolokiaProperties) jolokia.config.*= # See Jolokia manual # REMOTE SHELL shell.auth=simple # jaas, key, simple, spring shell.command-refresh-interval=-1 shell.command-path-pattern= # classpath*:/commands/**, classpath*:/crash/commands/** shell.config-path-patterns= # classpath*:/crash/* shell.disabled-plugins=false # don&apos;t expose plugins shell.ssh.enabled= # ssh settings ... shell.ssh.keyPath= shell.ssh.port= shell.telnet.enabled= # telnet settings ... shell.telnet.port= shell.auth.jaas.domain= # authentication settings ... shell.auth.key.path= shell.auth.simple.user.name= shell.auth.simple.user.password= shell.auth.spring.roles= # GIT INFO spring.git.properties= # resource ref to generated git info properties file]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA中使用mybatis generator逆向工程生成代码]]></title>
    <url>%2F2018%2F03%2F28%2FIDEA%E4%B8%AD%E4%BD%BF%E7%94%A8mybatis%20generator%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[本文介绍下如何在idea中利用Maven工具逆向生成mybatis代码 1. 在maven中配置pom.xml文件 在pom.xml的中加入如下插件： 12345678910&lt;!--mybatis 逆向工程--&gt;&lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;configuration&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt;&lt;/plugin&gt; 配置好maven插件后，进行下一步。 2. 添加逆向工程的配置文件 在resources目录下新建一个generatorConfig.xml文件，然后将如下配置文件拷贝到上面建的文件中。maven的项目配置文件存放位置如下： generatorConfig.xml文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;!--classPathEntry:数据库的JDBC驱动 --&gt; &lt;classPathEntry location=&quot;F:\.m2\repository\mysql\mysql-connector-java\5.1.34\mysql-connector-java-5.1.34.jar&quot; /&gt; &lt;!--&amp;lt;!&amp;ndash;导入属性配置&amp;ndash;&amp;gt;--&gt; &lt;!--&lt;properties resource=&quot;jdbc.properties&quot;&gt;&lt;/properties&gt;--&gt; &lt;context id=&quot;default&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;!-- optional，旨在创建class时，对注释进行控制 --&gt; &lt;commentGenerator&gt; &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt; &lt;/commentGenerator&gt; &lt;!--jdbc的数据库连接 --&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/cms&quot; userId=&quot;root&quot; password=&quot;sky&quot;&gt; &lt;/jdbcConnection&gt; &lt;!-- 非必需，类型处理器，在数据库类型和java类型之间的转换控制--&gt; &lt;javaTypeResolver&gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt; &lt;/javaTypeResolver&gt; &lt;!-- Model模型生成器,用来生成含有主键key的类，记录类 以及查询Example类 targetPackage 指定生成的model生成所在的包名 targetProject 指定在该项目下所在的路径 --&gt; &lt;javaModelGenerator targetPackage=&quot;com.spring.cms.model.vo&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;!-- 是否允许子包，即targetPackage.schemaName.tableName --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot;/&gt; &lt;!-- 是否对model添加 构造函数 --&gt; &lt;property name=&quot;constructorBased&quot; value=&quot;true&quot;/&gt; &lt;!-- 是否对类CHAR类型的列的数据进行trim操作 --&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt; &lt;!-- 建立的Model对象是否 不可改变 即生成的Model对象不会有 setter方法，只有构造方法 --&gt; &lt;property name=&quot;immutable&quot; value=&quot;false&quot;/&gt; &lt;/javaModelGenerator&gt; &lt;!--Mapper映射文件生成所在的目录 为每一个数据库的表生成对应的SqlMap文件 --&gt; &lt;sqlMapGenerator targetPackage=&quot;mapper&quot; targetProject=&quot;src/main/resources&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot;/&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 客户端代码，生成易于使用的针对Model对象和XML配置文件 的代码 type=&quot;ANNOTATEDMAPPER&quot;,生成Java Model 和基于注解的Mapper对象 type=&quot;MIXEDMAPPER&quot;,生成基于注解的Java Model 和相应的Mapper对象 type=&quot;XMLMAPPER&quot;,生成SQLMap XML文件和独立的Mapper接口 --&gt; &lt;javaClientGenerator targetPackage=&quot;com.spring.cms.dao&quot; targetProject=&quot;src/main/java&quot; type=&quot;XMLMAPPER&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt; &lt;/javaClientGenerator&gt; &lt;!-- 必须的（1...N） --&gt; &lt;!-- pojo 实体生成器 --&gt; &lt;!-- tableName:用于自动生成代码的数据库表；domainObjectName:对应于数据库表的javaBean类名 --&gt; &lt;!-- schema即为数据库名 可不写 --&gt; &lt;table tableName=&quot;cc_user&quot; domainObjectName=&quot;User&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;&gt; &lt;!-- 忽略字段 可选的（0 or 1） --&gt; &lt;!-- &lt;ignoreColumn column=&quot;is_use&quot; /&gt; --&gt; &lt;!--//无论字段是什么类型，生成的类属性都是varchar。 可选的（0 or 1） 测试无效 --&gt; &lt;!-- &lt;columnOverride column=&quot;city_code&quot; jdbcType=&quot;VARCHAR&quot; /&gt; --&gt; &lt;/table&gt; &lt;!-- 必须的（1...N） --&gt; &lt;!-- pojo 实体生成器 --&gt; &lt;!-- tableName:用于自动生成代码的数据库表；domainObjectName:对应于数据库表的javaBean类名 --&gt; &lt;!-- schema即为数据库名 可不写 --&gt; &lt;table tableName=&quot;cc_user_role&quot; domainObjectName=&quot;UserRole&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;&gt; &lt;!-- 忽略字段 可选的（0 or 1） --&gt; &lt;!-- &lt;ignoreColumn column=&quot;is_use&quot; /&gt; --&gt; &lt;!--//无论字段是什么类型，生成的类属性都是varchar。 可选的（0 or 1） 测试无效 --&gt; &lt;!-- &lt;columnOverride column=&quot;city_code&quot; jdbcType=&quot;VARCHAR&quot; /&gt; --&gt; &lt;/table&gt; &lt;!-- 必须的（1...N） --&gt; &lt;!-- pojo 实体生成器 --&gt; &lt;!-- tableName:用于自动生成代码的数据库表；domainObjectName:对应于数据库表的javaBean类名 --&gt; &lt;!-- schema即为数据库名 可不写 --&gt; &lt;table tableName=&quot;cc_role&quot; domainObjectName=&quot;Role&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;&gt; &lt;!-- 忽略字段 可选的（0 or 1） --&gt; &lt;!-- &lt;ignoreColumn column=&quot;is_use&quot; /&gt; --&gt; &lt;!--//无论字段是什么类型，生成的类属性都是varchar。 可选的（0 or 1） 测试无效 --&gt; &lt;!-- &lt;columnOverride column=&quot;city_code&quot; jdbcType=&quot;VARCHAR&quot; /&gt; --&gt; &lt;/table&gt; &lt;!-- 必须的（1...N） --&gt; &lt;!-- pojo 实体生成器 --&gt; &lt;!-- tableName:用于自动生成代码的数据库表；domainObjectName:对应于数据库表的javaBean类名 --&gt; &lt;!-- schema即为数据库名 可不写 --&gt; &lt;table tableName=&quot;cc_role_resource&quot; domainObjectName=&quot;RoleResource&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;&gt; &lt;!-- 忽略字段 可选的（0 or 1） --&gt; &lt;!-- &lt;ignoreColumn column=&quot;is_use&quot; /&gt; --&gt; &lt;!--//无论字段是什么类型，生成的类属性都是varchar。 可选的（0 or 1） 测试无效 --&gt; &lt;!-- &lt;columnOverride column=&quot;city_code&quot; jdbcType=&quot;VARCHAR&quot; /&gt; --&gt; &lt;/table&gt; &lt;!-- 必须的（1...N） --&gt; &lt;!-- pojo 实体生成器 --&gt; &lt;!-- tableName:用于自动生成代码的数据库表；domainObjectName:对应于数据库表的javaBean类名 --&gt; &lt;!-- schema即为数据库名 可不写 --&gt; &lt;table tableName=&quot;cc_resource&quot; domainObjectName=&quot;Resource&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;&gt; &lt;!-- 忽略字段 可选的（0 or 1） --&gt; &lt;!-- &lt;ignoreColumn column=&quot;is_use&quot; /&gt; --&gt; &lt;!--//无论字段是什么类型，生成的类属性都是varchar。 可选的（0 or 1） 测试无效 --&gt; &lt;!-- &lt;columnOverride column=&quot;city_code&quot; jdbcType=&quot;VARCHAR&quot; /&gt; --&gt; &lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; jdbc.properties配置文件的代码如下： 12345678910driverClassName=com.mysql.jdbc.DrivervalidationQuery=SELECT 1jdbc_url=jdbc:mysql://localhost:3306/contentmanagersystem_db?useUnicode=true&amp;characterEncoding=UTF-8&amp;zeroDateTimeBehavior=convertToNulljdbc_username=rootjdbc_password=skyjdbc.mysql-master.initialSize=5jdbc.mysql-master.maxActive=5jdbc.mysql-master.maxIdle=5jdbc.mysql-master.minIdle=1jdbc.mysql-master.maxWait=6000 3. 在IDEA中利用插件生成代码 选择IDEA右上角下拉框中的Edit Configurations,然后进入到配置页面，选择做上角的 + 号，如图： 选择maven，然后在Commond line栏填上如图命令 点击应用。最后点击启动按钮，即可自动生成代码。 生成成功！]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[logback的使用和logback的配置]]></title>
    <url>%2F2018%2F03%2F17%2Flogback%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8Clogback%E7%9A%84%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[一.logback的介绍&emsp;&emsp;Logback是由log4j创始人设计的另一个开源日志组件,官方网站：http://logback.qos.ch。它当前分为下面下个模块： &emsp;&emsp;logback-core：其它两个模块的基础模块&emsp;&emsp;它是log4j的一个改良版本，同时它完整实现了slf4j API使你可以很方便地更换成其它日志系统如log4j或JDK14 Logging&emsp;&emsp;访问模块与Servlet容器集成提供通过Http来访问日志的功能 二.logback取代log4j的理由：&emsp;&emsp;1、更快的实现：Logback的内核重写了，在一些关键执行路径上性能提升10倍以上。而且logback不仅性能提升了，初始化内存加载也更小了。&emsp;&emsp;2、非常充分的测试：Logback经过了几年，数不清小时的测试。Logback的测试完全不同级别的。&emsp;&emsp;3、Logback-classic非常自然实现了SLF4j：Logback-classic实现了SLF4j。在使用SLF4j中，你都感觉不到logback-classic。而且因为logback-classic非常自然地实现了slf4j ， 所 以切换到log4j或者其他，非常容易，只需要提供成另一个jar包就OK，根本不需要去动那些通过SLF4JAPI实现的代码。&emsp;&emsp;4、非常充分的文档 官方网站有两百多页的文档。&emsp;&emsp;5、自动重新加载配置文件，当配置文件修改了，Logback-classic能自动重新加载配置文件。扫描过程快且安全，它并不需要另外创建一个扫描线程。这个技术充分保证了应用程序能跑得很欢在JEE环境里面。&emsp;&emsp;6、Lilith是log事件的观察者，和log4j的chainsaw类似。而lilith还能处理大数量的log数据 。&emsp;&emsp;7、谨慎的模式和非常友好的恢复，在谨慎模式下，多个FileAppender实例跑在多个JVM下，能 够安全地写道同一个日志文件。RollingFileAppender会有些限制。Logback的FileAppender和它的子类包括 RollingFileAppender能够非常友好地从I/O异常中恢复。&emsp;&emsp;8、配置文件可以处理不同的情况，开发人员经常需要判断不同的Logback配置文件在不同的环境下（开发，测试，生产）。而这些配置文件仅仅只有一些很小的不同，可以通过,和来实现，这样一个配置文件就可以适应多个环境。&emsp;&emsp;9、Filters（过滤器）有些时候，需要诊断一个问题，需要打出日志。在log4j，只有降低日志级别，不过这样会打出大量的日志，会影响应用性能。在Logback，你可以继续 保持那个日志级别而除掉某种特殊情况，如alice这个用户登录，她的日志将打在DEBUG级别而其他用户可以继续打在WARN级别。要实现这个功能只需加4行XML配置。可以参考MDCFIlter 。&emsp;&emsp;10、SiftingAppender（一个非常多功能的Appender）：它可以用来分割日志文件根据任何一个给定的运行参数。如，SiftingAppender能够区别日志事件跟进用户的Session，然后每个用户会有一个日志文件。&emsp;&emsp;11、自动压缩已经打出来的log：RollingFileAppender在产生新文件的时候，会自动压缩已经打出来的日志文件。压缩是个异步过程，所以甚至对于大的日志文件，在压缩过程中应用不会受任何影响。&emsp;&emsp;12、堆栈树带有包版本：Logback在打出堆栈树日志时，会带上包的数据。&emsp;&emsp;13、自动去除旧的日志文件：通过设置TimeBasedRollingPolicy或者SizeAndTimeBasedFNATP的maxHistory属性，你可以控制已经产生日志文件的最大数量。如果设置maxHistory 12，那那些log文件超过12个月的都会被自动移除。 三、logback的配置介绍&emsp;&emsp;1、Logger、appender及layout&emsp;&emsp;Logger作为日志的记录器，把它关联到应用的对应的context上后，主要用于存放日志对象，也可以定义日志类型、级别。&emsp;&emsp;Appender主要用于指定日志输出的目的地，目的地可以是控制台、文件、远程套接字服务器、 MySQL、PostreSQL、 Oracle和其他数据库、 JMS和远程UNIX Syslog守护进程等。&emsp;&emsp;Layout 负责把事件转换成字符串，格式化的日志信息的输出。&emsp;&emsp;2、logger context&emsp;&emsp;各个logger 都被关联到一个 LoggerContext，LoggerContext负责制造logger，也负责以树结构排列各logger。其他所有logger也通过org.slf4j.LoggerFactory 类的静态方法getLogger取得。 getLogger方法以 logger名称为参数。用同一名字调用LoggerFactory.getLogger 方法所得到的永远都是同一个logger对象的引用。&emsp;&emsp;3、有效级别及级别的继承&emsp;&emsp;Logger 可以被分配级别。级别包括：TRACE、DEBUG、INFO、WARN 和 ERROR，定义于ch.qos.logback.classic.Level类。如果 logger没有被分配级别，那么它将从有被分配级别的最近的祖先那里继承级别。root logger 默认级别是 DEBUG。&emsp;&emsp;4、打印方法与基本的选择规则&emsp;&emsp;打印方法决定记录请求的级别。例如，如果 L 是一个 logger 实例，那么，语句 L.info(“..”)是一条级别为 INFO的记录语句。记录请求的级别在高于或等于其 logger 的有效级别时被称为被启用，否则，称为被禁用。记录请求级别为 p，其 logger的有效级别为 q，只有则当 p&gt;=q时，该请求才会被执行。该规则是 logback 的核心。级别排序为： TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR 四、logback的默认配置&emsp;&emsp;如果配置文件 logback-test.xml 和 logback.xml 都不存在，那么 logback 默认地会调用BasicConfigurator ，创建一个最小化配置。最小化配置由一个关联到根 logger 的ConsoleAppender 组成。输出用模式为%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n 的 PatternLayoutEncoder 进行格式化。root logger 默认级别是 DEBUG。&emsp;&emsp;1、Logback的配置文件&emsp;&emsp;Logback 配置文件的语法非常灵活。正因为灵活，所以无法用 DTD 或 XML schema 进行定义。尽管如此，可以这样描述配置文件的基本结构：以开头，后面有零个或多个元素，有零个或多个元素，有最多一个元素。&emsp;&emsp;2、Logback默认配置步骤&emsp;&emsp;&nbsp;(1). 尝试在 classpath下查找文件logback-test.xml；&emsp;&emsp;&nbsp;(2). 如果文件不存在，则查找文件logback.xml；&emsp;&emsp;&nbsp;(3). 如果两个文件都不存在，logback用BasicConfigurator自动对自己进行配置，这会导致记录输出到控制台。 五、logback.xml常用配置详解&emsp;&emsp;1、根节点，包含下面三个属性：&emsp;&emsp;scan: 当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。&emsp;&emsp;scanPeriod: 设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。&emsp;&emsp;debug: 当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。例如: 123&lt;configuration scan=&quot;true&quot; scanPeriod=&quot;60 seconds&quot; debug=&quot;false&quot;&gt; &lt;!--其他配置省略--&gt;&lt;/configuration&gt; &emsp;&emsp;2、子节点：用来设置上下文名称，每个logger都关联到logger上下文，默认上下文名称为default。但可以使用设置成其他名字，用于区分不同应用程序的记录。一旦设置，不能修改。例如： 1234&lt;configuration scan=&quot;true&quot; scanPeriod=&quot;60 seconds&quot; debug=&quot;false&quot;&gt; &lt;contextName&gt;myAppName&lt;/contextName&gt; &lt;!--其他配置省略--&gt;&lt;/configuration&gt; &emsp;&emsp;3、子节点：用来定义变量值，它有两个属性name和value，通过定义的值会被插入到logger上下文中，可以使“${}”来使用变量。&emsp;&emsp;&emsp;name: 变量的名称&emsp;&emsp;&emsp;value: 的值时变量定义的值例如：12345&lt;configuration scan=&quot;true&quot; scanPeriod=&quot;60 seconds&quot; debug=&quot;false&quot;&gt; &lt;property name=&quot;APP_Name&quot; value=&quot;myAppName&quot; /&gt; &lt;contextName&gt;$&#123;APP_Name&#125;&lt;/contextName&gt; &lt;!--其他配置省略--&gt;&lt;/configuration&gt; &emsp;&emsp;4、子节点：获取时间戳字符串，他有两个属性key和datePattern&emsp;&emsp;key: 标识此 的名字；&emsp;&emsp;datePattern: 设置将当前时间（解析配置文件的时间）转换为字符串的模式，遵循java.txt.SimpleDateFormat的格式。例如：12345&lt;configuration scan=&quot;true&quot; scanPeriod=&quot;60 seconds&quot; debug=&quot;false&quot;&gt; &lt;timestamp key=&quot;bySecond&quot; datePattern=&quot;yyyyMMdd&apos;T&apos;HHmmss&quot;/&gt; &lt;contextName&gt;$&#123;bySecond&#125;&lt;/contextName&gt; &lt;!-- 其他配置省略--&gt;&lt;/configuration&gt; &emsp;&emsp;5、子节点：负责写日志的组件，它有两个必要属性name和class。name指定appender名称，class指定appender的全限定名 &emsp;&emsp;&emsp;5.1、ConsoleAppender 把日志输出到控制台，有以下子节点：12&lt;encoder&gt;：对日志进行格式化。（具体参数稍后讲解 ）&lt;target&gt;：字符串System.out(默认)或者System.err（区别不多说了） 例如：1234567891011&lt;configuration&gt; &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;encoder&gt; &lt;pattern&gt;%-4relative [%thread] %-5level %logger&#123;35&#125; - %msg %n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level=&quot;DEBUG&quot;&gt; &lt;appender-ref ref=&quot;STDOUT&quot; /&gt; &lt;/root&gt;&lt;/configuration&gt; &emsp;&emsp;上述配置表示把&gt;=DEBUG级别的日志都输出到控制台 &emsp;&emsp;&emsp;5.2、FileAppender：把日志添加到文件，有以下子节点：1234&lt;file&gt;：被写入的文件名，可以是相对目录，也可以是绝对目录，如果上级目录不存在会自动创建，没有默认值。&lt;append&gt;：如果是 true，日志被追加到文件结尾，如果是 false，清空现存文件，默认是true。&lt;encoder&gt;：对记录事件进行格式化。（具体参数稍后讲解 ）&lt;prudent&gt;：如果是 true，日志会被安全的写入文件，即使其他的FileAppender也在向此文件做写入操作，效率低，默认是 false。 例如：12345678910111213&lt;configuration&gt; &lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.FileAppender&quot;&gt; &lt;file&gt;testFile.log&lt;/file&gt; &lt;append&gt;true&lt;/append&gt; &lt;encoder&gt; &lt;pattern&gt;%-4relative [%thread] %-5level %logger&#123;35&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level=&quot;DEBUG&quot;&gt; &lt;appender-ref ref=&quot;FILE&quot; /&gt; &lt;/root&gt;&lt;/configuration&gt; &emsp;&emsp;上述配置表示把&gt;=DEBUG级别的日志都输出到testFile.log &emsp;&emsp;&emsp;5.3、RollingFileAppender：滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件。有以下子节点：1234567891011121314&lt;file&gt;：被写入的文件名，可以是相对目录，也可以是绝对目录，如果上级目录不存在会自动创建，没有默认值。&lt;append&gt;：如果是 true，日志被追加到文件结尾，如果是 false，清空现存文件，默认是true。 &lt;rollingPolicy&gt;:当发生滚动时，决定RollingFileAppender的行为，涉及文件移动和重命名。属性class定义具体的滚动策略类 class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;： 最常用的滚动策略，它根据时间来制定滚动策略，既负责滚动也负责出发滚动。有以下子节点：&lt;fileNamePattern&gt;：必要节点，包含文件名及“%d”转换符，“%d”可以包含一个java.text.SimpleDateFormat指定的时间格式，如：%d&#123;yyyy-MM&#125;。如果直接使用 %d，默认格式是 yyyy-MM-dd。RollingFileAppender的file字节点可有可无，通过设置file，可以为活动文件和归档文件指定不同位置，当前日志总是记录到file指定的文件（活动文件），活动文件的名字不会改变；如果没设置file，活动文件的名字会根据fileNamePattern 的值，每隔一段时间改变一次。“/”或者“\”会被当做目录分隔符。 &lt;maxHistory&gt;:可选节点，控制保留的归档文件的最大数量，超出数量就删除旧文件。假设设置每个月滚动，且&lt;maxHistory&gt;是6，则只保存最近6个月的文件，删除之前的旧文件。注意，删除旧文件是，那些为了归档而创建的目录也会被删除。 class=&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;： 查看当前活动文件的大小，如果超过指定大小会告知RollingFileAppender 触发当前活动文件滚动。只有一个节点:&lt;maxFileSize&gt;:这是活动文件的大小，默认值是10MB。&lt;prudent&gt;：当为true时，不支持FixedWindowRollingPolicy。支持TimeBasedRollingPolicy，但是有两个限制，1不支持也不允许文件压缩，2不能设置file属性，必须留空。 &lt;triggeringPolicy &gt;: 告知 RollingFileAppender 合适激活滚动。 class=&quot;ch.qos.logback.core.rolling.FixedWindowRollingPolicy&quot; 根据固定窗口算法重命名文件的滚动策略。有以下子节点：&lt;minIndex&gt;:窗口索引最小值&lt;maxIndex&gt;:窗口索引最大值，当用户指定的窗口过大时，会自动将窗口设置为12。&lt;fileNamePattern&gt;:必须包含“%i”例如，假设最小值和最大值分别为1和2，命名模式为 mylog%i.log,会产生归档文件mylog1.log和mylog2.log。还可以指定文件压缩选项，例如，mylog%i.log.gz 或者 没有log%i.log.zip 例如：12345678910111213141516171819202122232425262728293031323334353637&lt;configuration&gt; &lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt; fileNamePattern&gt;logFile.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%-4relative [%thread] %-5level %logger&#123;35&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level=&quot;DEBUG&quot;&gt; &lt;appender-ref ref=&quot;FILE&quot; /&gt; &lt;/root&gt;&lt;/configuration&gt;//上述配置表示每天生成一个日志文件，保存30天的日志文件。&lt;configuration&gt; &lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;file&gt;test.log&lt;/file&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.FixedWindowRollingPolicy&quot;&gt; &lt;fileNamePattern&gt; tests.%i.log.zip &lt;/fileNamePattern&gt; &lt;minIndex&gt;1&lt;/minIndex&gt; &lt;maxIndex&gt;3&lt;/maxIndex&gt; &lt;/rollingPolicy&gt; &lt;triggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;&gt; &lt;maxFileSize&gt;5MB&lt;/maxFileSize&gt; &lt;/triggeringPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%-4relative [%thread] %-5level %logger&#123;35&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level=&quot;DEBUG&quot;&gt; &lt;appender-ref ref=&quot;FILE&quot; /&gt; &lt;/root&gt;&lt;/configuration&gt; &emsp;&emsp;上述配置表示按照固定窗口模式生成日志文件，当文件大于20MB时，生成新的日志文件。窗口大小是1到3，当保存了3个归档文件后，将覆盖最早的日志。12&lt;encoder&gt;：对记录事件进行格式化。负责两件事，一是把日志信息转换成字节数组，二是把字节数组写入到输出流。PatternLayoutEncoder 是唯一有用的且默认的encoder ，有一个&lt;pattern&gt;节点，用来设置日志的输入格式。使用“%”加“转换符”方式，如果要输出“%”，则必须用“\”对“\%”进行转义。 &emsp;&emsp;&emsp;5.4、还有SocketAppender、SMTPAppender、DBAppender、SyslogAppender、SiftingAppender，并不常用，这里就不详解了。大家可以参考官方文档(http://logback.qos.ch/documentation.html)，还可以编写自己的Appender。 &emsp;&emsp;6、子节点：用来设置某一个包或具体的某一个类的日志打印级别、以及指定。仅有一个name属性，一个可选的level和一个可选的addtivity属性。可以包含零个或多个元素，标识这个appender将会添加到这个loger。&emsp;&emsp;name: 用来指定受此loger约束的某一个包或者具体的某一个类。&emsp;&emsp;level: 用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL和OFF，还有一个特俗值INHERITED或者同义词NULL，代表强制执行上级的级别。 如果未设置此属性，那么当前loger将会继承上级的级别。1addtivity: 是否向上级loger传递打印信息。默认是true。同&lt;loger&gt;一样，可以包含零个或多个&lt;appender-ref&gt;元素，标识这个appender将会添加到这个loger。 &emsp;&emsp;7、子节点:它也是元素，但是它是根loger,是所有的上级。只有一个level属性，因为name已经被命名为”root”,且已经是最上级了。 level: 用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL和OFF，不能设置为INHERITED或者同义词NULL。 默认是DEBUG。 六、常用loger配置123456789101112&lt;!-- show parameters for hibernate sql 专为 Hibernate 定制 --&gt;&lt;logger name=&quot;org.hibernate.type.descriptor.sql.BasicBinder&quot; level=&quot;TRACE&quot; /&gt;&lt;logger name=&quot;org.hibernate.type.descriptor.sql.BasicExtractor&quot; level=&quot;DEBUG&quot; /&gt;&lt;logger name=&quot;org.hibernate.SQL&quot; level=&quot;DEBUG&quot; /&gt;&lt;logger name=&quot;org.hibernate.engine.QueryParameters&quot; level=&quot;DEBUG&quot; /&gt;&lt;logger name=&quot;org.hibernate.engine.query.HQLQueryPlan&quot; level=&quot;DEBUG&quot; /&gt;&lt;!--myibatis log configure--&gt;&lt;logger name=&quot;com.apache.ibatis&quot; level=&quot;TRACE&quot;/&gt;&lt;logger name=&quot;java.sql.Connection&quot; level=&quot;DEBUG&quot;/&gt;&lt;logger name=&quot;java.sql.Statement&quot; level=&quot;DEBUG&quot;/&gt;&lt;logger name=&quot;java.sql.PreparedStatement&quot; level=&quot;DEBUG&quot;/&gt; 七、Demo&emsp;&emsp;1、添加依赖包logback使用需要和slf4j一起使用，所以总共需要添加依赖的包有slf4j-apilogback使用需要和slf4j一起使用，所以总共需要添加依赖的包有slf4j-api.jar，logback-core.jar，logback-classic.jar，logback-access.jar这个暂时用不到所以不添加依赖了，maven配置123456789101112131415161718192021222324&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;logback.version&gt;1.1.7&lt;/logback.version&gt; &lt;slf4j.version&gt;1.7.21&lt;/slf4j.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;$&#123;logback.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;$&#123;logback.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &emsp;&emsp;2、logback.xml配置12345678910111213141516171819202122232425262728293031323334&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration debug=&quot;false&quot;&gt;&lt;!--定义日志文件的存储地址 勿在 LogBack 的配置中使用相对路径--&gt;&lt;property name=&quot;LOG_HOME&quot; value=&quot;/home&quot; /&gt;&lt;!-- 控制台输出 --&gt;&lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;&lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt;&lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt;&lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt;&lt;/encoder&gt;&lt;/appender&gt;&lt;!-- 按照每天生成日志文件 --&gt;&lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;&lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;&lt;!--日志文件输出的文件名--&gt;&lt;FileNamePattern&gt;$&#123;LOG_HOME&#125;/TestWeb.log.%d&#123;yyyy-MM-dd&#125;.log&lt;/FileNamePattern&gt;&lt;!--日志文件保留天数--&gt;&lt;MaxHistory&gt;30&lt;/MaxHistory&gt;&lt;/rollingPolicy&gt;&lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt;&lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt;&lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt;&lt;/encoder&gt;&lt;!--日志文件最大的大小--&gt;&lt;triggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;&gt;&lt;MaxFileSize&gt;10MB&lt;/MaxFileSize&gt;&lt;/triggeringPolicy&gt;&lt;/appender&gt;&lt;!-- 日志输出级别 --&gt;&lt;root level=&quot;INFO&quot;&gt;&lt;appender-ref ref=&quot;STDOUT&quot; /&gt;&lt;/root&gt;&lt;/configuration&gt; &emsp;&emsp;3、java代码12345678910111213/** * Hello world! */ public class App &#123; private final static Logger logger = LoggerFactory.getLogger(App.class); public static void main(String[] args) &#123; logger.info(&quot;logback 成功了&quot;); logger.error(&quot;logback 成功了&quot;); logger.debug(&quot;logback 成功了&quot;); &#125; &#125; &emsp;&emsp;4、输出 八、总结&emsp;&emsp;logback的配置，需要配置输出源appender，打日志的loger（子节点）和root（根节点），实际上，它输出日志是从子节点开始，子节点如果有输出源直接输入，如果无，判断配置的addtivity，是否像上级传递，即是否向root传递，传递则采用root的输出源，否则不输出日志。]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrryList和LinkedList的区别]]></title>
    <url>%2F2018%2F01%2F06%2FArrayList%E5%92%8CLinkedList%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[相同点：ArrayList和LinkedList类都位于java.util包中，均为可收缩数组，即可以动态的改变数组的长度。]]></content>
      <categories>
        <category>容器</category>
      </categories>
      <tags>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[容器主要类型的区分]]></title>
    <url>%2F2018%2F01%2F03%2F%E5%AE%B9%E5%99%A8%E4%B8%BB%E8%A6%81%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%86%2F</url>
    <content type="text"><![CDATA[容器的基本概念Java 容器类类库的概念是“保存对象”，通常将其划分为两个不同的概念： Collection: 一个独立元素的序列，这些元素都服从一条或多条规则。List 必须按照插入的顺序保存元素，而Set不能有重复元素。Queue按照排队规则来确定能够对象产生的顺序（通常与它们被插入的顺序相同）。 Map: 一组成对的“键值对”对象，允许你使用键来查找值。映射表允许我们使用另一个对象来查找某个对象，它也被成为“关联数组”，因为它将某些对象与另外一些对象关联在一起；或者被称为“字典”，因为你可以使用键对象来查找值对象。Map是强大的编程工具。 容器中的几种不同的存贮方式先来看一个小例子： 1234567891011121314151617181920212223242526public class PrintingContainers &#123; public static Collection fill(Collection&lt;String&gt; collection)&#123; collection.add(&quot;Snow&quot;); collection.add(&quot;White&quot;); collection.add(&quot;Star&quot;); collection.add(&quot;Wars&quot;); return collection; &#125; public static Map fill(Map&lt;String,String&gt; map)&#123; map.put(&quot;Snow&quot;,&quot;Tom&quot;); map.put(&quot;White&quot;,&quot;Jerry&quot;); map.put(&quot;Star&quot;,&quot;Jack&quot;); map.put(&quot;Wars&quot;,&quot;Angle&quot;); return map; &#125; public static void main(String[] args)&#123; System.out.println(fill(new ArrayList&lt;String&gt;())); System.out.println(fill(new LinkedList&lt;String&gt;())); System.out.println(fill(new HashSet&lt;String&gt;())); System.out.println(fill(new LinkedHashSet&lt;String&gt;())); System.out.println(fill(new TreeSet&lt;String&gt;())); System.out.println(fill(new HashMap&lt;String,String&gt;())); System.out.println(fill(new TreeMap&lt;String,String&gt;())); System.out.println(fill(new LinkedHashMap&lt;String,String&gt;())); &#125;&#125; 代码运行的结果为： 以上代码展示了Java容器类库中的两种主要类型，它们的区别在于容器中每个“槽”保存的元素的个数。Collection在每个“槽”中只能存贮一个元素。此类容器包括：List，它已特定的顺序保存一组元素；Set，元素之间不能重复；Queue，只允许在容器的一端插入对象，并从另外一端移除对象。Map在每个槽中存贮了两个对象，即一个键值对。 上面的代码中首先利用fill()方法给所有类型的Collection容器添加元素add()方法。fill()方法可以作用于所有类型的Collection。 ArrayList和LinkedList都是List类型，两者都属于可伸缩数组，可以动态的改变数组的长度。从输出的结果可以看出，它们都是按照被插入的顺序来保存元素。两者的不同之处不仅在于执行某些类型的操作时的性能，而且LinkedList包含的操作也多余ArrayList。]]></content>
      <categories>
        <category>容器</category>
      </categories>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程的几种实现方式]]></title>
    <url>%2F2018%2F01%2F02%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是线程？ 线程是指程序在执行过程中，能够执行程序程序代码的一个执行单元。在Java语言中，线程有四种状态：运行、就绪、挂起和结束。 为什么要使用多线程 使用多哦线程可以减少程序的相应时间。 多CPU或多核计算机本身就具有执行多线程的能力。 与进程相比，线程的创建和切换开销更小。 使用多线程能简化程序的结构，使程序便于维护和理解。一个非常复杂的进程可以分成多个线程来执行。 基本的线程机制在使用线程时，CPU将轮流给每个任务分配其占用时间。每个任务都觉得自己在一直占用着CPU,但事实上CPU时间是划分成片段分配给所有的任务。线程可以使你从这个层次抽身出来。注意：当系统使用时间切片机制时，CPU轮流给每个任务分配时间，例如Windows（线程优先级和时间片轮转调度）操作系统。但有些操作系统采用FIFO模型，除非有高优先级的线程被唤醒，否则当前线程将一直运行，直至阻塞或终止。 如何实现Java多线程继承Thread类，重写run()方法Thread 本质上也是实现了Runnable接口的一个实例，它代表一个线程的实例，并且，启动线程的唯一方法就是通过Thread类的start()方法。start()方法是一个native(本地)方法，它将启动一个新线程，并执行一个run()方法(Thread中提供的run()方法是一个空方法)。这种方式通过自定义直接继承Thread，并重写run()方法，就可以启动新线程并执行自己定义的run()方法。调用start()方法后并不是立即执行多线程代码，而是使得该线程变成可运行态，什么时候运行多线程是由CPU调度决定的 1234567891011class MyThread extends Thread&#123; public void run()&#123; System.out.println(&quot;Thread body&quot;); &#125; &#125; public class Test&#123; public static void main(String[] args)&#123; MyThread thread=new MyThread(); thread.run(); &#125; &#125; 实现Runnable接口，并实现该接口的run()方法主要步骤：1） 自定义类并实现Runnable接口，并实现run()方法。2） 创建Thread对象，用实现Runnable接口的对象作为参数实例化该Thread对象。3） 调用Thread的start()方法。 123456789101112class MyThread implements Runnable&#123; public void run()&#123; System.out.println(&quot;Thread body&quot;); &#125;&#125;public class Test&#123; public static void main(String[] args)&#123; MyThread thread=new MyThread(); Thread t=new Thread(thread); t.start(); &#125;&#125; 以上两种是实现多线程最常用的方法。 其实不管是通过继承Thread类还是通过使用Runnable接口来实现多线程的方法，最终还是通过Thread的对象的API来控制线程的。 实现Callable接口，重写call()方法Callable接口实际上是属于Executor框架的功能类，Callable接口与Runnable接口的功能类类似，但提供了比Runnable更强大的功能，主要表现在以下三点：1）Callable可以在任务结束后提供一个返回值，Runnable无法提供这个功能。2）Callable中的call()方法可以抛出异常，而Runnable的run()方法无法抛出异常。3）运行Callable可以拿到一个Future对象，Future对象表示异步计算的结果，可以使用Future来监视目标线程调用call()方法的情况，当调用Future的get()方法以获取结果时，当前线程就会阻塞，直到call()方法结束返回结果。 12345678910111213141516171819202122public class CallableAndFuture&#123; //创建线程类 public static class CallableTest implements Callable&lt;String&gt;&#123; @Override public String call() throws Exception &#123; return &quot;欢迎来到我的博客！&quot;; &#125; &#125; public static void main(String[] args)&#123; ExecutorService threadPool= Executors.newSingleThreadExecutor(); //启动线程 Future&lt;String&gt; future=threadPool.submit(new CallableTest()); try &#123; System.out.println(&quot;waiting thread to finish&quot;); //等待线程结束，并获取返回结果 System.out.println(future.get()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 上述程序的输出结果为： 以上3中方式中，前两种方式线程执行完后都没有返回值，只有最后一种带有返回值的，但是当需要使用多线程时，一般最好是使用实现Runnable接口的方式。因为Thread类定义的多中方法可以被派生类使用或者重写。但是只有run()方法是必须被重写的，在run()方法中实现了这个线程的主要功能。]]></content>
      <categories>
        <category>线程</category>
      </categories>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git总结]]></title>
    <url>%2F2018%2F01%2F01%2Fgit%2F</url>
    <content type="text"><![CDATA[git 简介git 是一款分布式的版本控制系统，其核心是分支，分支的意义在于可以将项目代码按照功能和模块拆分为不同的分支。在 git 中，工作目录下面的所有文件都不外乎两种状态： 已跟踪和未跟踪。 已跟踪文件是指已经被纳入git中，在版本控制器中有它们的记录，但是当我们对文件进行修改之后，文件变得和git中的不一样，那么它就属于未跟踪文件。初次克隆某个仓库时，所有文件都属于已跟踪文件。 git 常用指令git pull作用 将远程代码仓库里的代码下载下来并自动整合到当前工作分支 用法： git pull origin master 将origin这个版本库中的代码更新到本地的master主支，类似于SVN的update git add作用 是将当前更改或者新增的文件加入到Git的索引中，加入到Git的索引中就表示记入了版本历史中，这也是提交之前所需要执行的一步 用法： git add app/model/user.java 增加app/model/user.java文件到Git的索引中,该功能类似于SVN的add git rm作用 从当前的工作空间中和索引中删除文件 用法： git rm app/model/user.java 删除工作空间中或者索引中的app/model/user.java文件，该功能类似于SVN的rm、del git commit作用 将所有添加到索引库的文件添加到本地仓库文件一旦commit之后，就会在git中形成一个历史版本，以后无论怎么变都能够找到此次提交的记录。 用法： git commit -m story #3, add user model 提交的时候必须用-m来输入一条提交信息，该功能类似于SVN中的commit git push作用 将本地仓库中的修改推送到远程仓库 用法：git push origin 将本地的代码推送到名为origin的远程版本库中 git log作用 查看git的历史日志 该功能类似于SVN的log git revert作用 还原一个版本的修改，必须提供一个具体的Git版本号，Git的版本号都是生成的一个哈希值 用法：git revert bbaf6fb5060b4875b18ff9ff637ce118256d6f20]]></content>
      <categories>
        <category>环境</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F12%2F30%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
